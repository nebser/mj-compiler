package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

terminal PROGRAM, CONST, COMMA, CLASS, EXTENDS, ABSTRACT, ASSIGN;
terminal String IDENT, CHARACTER, BOOL;
terminal Integer NUMBER;
terminal SEMI_COLON, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal LPARENTHESIS, RPARENTHESIS, VOID;
terminal IF, ELSE, FOR, BREAK, CONTINUE, RETURN, READ, PRINT;
terminal INCREMENT, DECREMENT, OR, AND;
terminal MINUS, PLUS, MULTIPLY, DIVIDE, MOD;
terminal NEW, COLON;
terminal EQUALS, DIFFERS, GREATER, GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL;

nonterminal DeclSection DeclSection;
nonterminal DeclList DeclList;
nonterminal DeclElem DeclElem;
nonterminal MethodDeclSection MethodDeclSection;
nonterminal MethodDecl MethodDecl;
nonterminal VarDecl VarDecl;
nonterminal AbstractClassDecl AbstractClassDecl;
nonterminal ClassDecl ClassDecl;
nonterminal ConstList ConstList;
nonterminal Const Const;
nonterminal ConstDefinition ConstDefinition;
nonterminal VarDeclSection VarDeclSection;
nonterminal VarDeclList VarDeclList;
nonterminal VarList VarList;
nonterminal Var Var;
nonterminal Program Program;
nonterminal Type Type;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal AnyMethodDeclSection AnyMethodDeclSection;
nonterminal AnyMethodDeclList AnyMethodDeclList;
nonterminal AnyMethodDecl AnyMethodDecl;
nonterminal ReturnType ReturnType;
nonterminal FormPars FormPars;
nonterminal AbstractMethodDecl AbstractMethodDecl;
nonterminal MethodDeclList MethodDeclList;
nonterminal ExtendsStmt ExtendsStmt;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal Condition Condition;
nonterminal Matched Matched;
nonterminal Unmatched Unmatched;
nonterminal OptionalDesignatorStatement OptionalDesignatorStatement;
nonterminal ForStatement ForStatement;
nonterminal ReturnExpr ReturnExpr;
nonterminal Expr Expr;
nonterminal Designator Designator;
nonterminal Assignop Assignop;
nonterminal ActPars ActPars;
nonterminal ExprList ExprList;
nonterminal Relop Relop;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal AddExprPart AddExprPart;
nonterminal Addop Addop;
nonterminal Term Term;
nonterminal Factor Factor;
nonterminal FactorList FactorList;
nonterminal Mulop Mulop;
nonterminal DesignatorSuffix DesignatorSuffix;
nonterminal FormParsList FormParsList;

Program ::= (Program) PROGRAM IDENT:I1 DeclSection:D2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(I1, D2, M3); RESULT.setLine(I1left); :};

DeclSection ::= (DeclarationSection) DeclList:D1 {: RESULT=new DeclarationSection(D1); RESULT.setLine(D1left); :}
				|
				(NoDeclarationSection) {: RESULT=new NoDeclarationSection(); :} /* epsilon */
				;

DeclList ::= (Declarations) DeclList:D1 DeclElem:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
			|
			(Declaration) DeclElem:D1 {: RESULT=new Declaration(D1); RESULT.setLine(D1left); :}
			;
			
DeclElem ::= (ConstantDeclarations) CONST Type:T1 ConstList:C2 {: RESULT=new ConstantDeclarations(T1, C2); RESULT.setLine(T1left); :}
			|
			(GlobalVariableDeclarations) VarDecl:V1 {: RESULT=new GlobalVariableDeclarations(V1); RESULT.setLine(V1left); :}
			|
			(GlobalAbstactClassDeclarations) AbstractClassDecl:A1 {: RESULT=new GlobalAbstactClassDeclarations(A1); RESULT.setLine(A1left); :}
			|
			(GlobalClassDeclarations) ClassDecl:C1 {: RESULT=new GlobalClassDeclarations(C1); RESULT.setLine(C1left); :}
			;

ConstList ::= (Constants) ConstDefinition:C1 COMMA ConstList:C2 {: RESULT=new Constants(C1, C2); RESULT.setLine(C1left); :}
			|
			 (Constant) ConstDefinition:C1 SEMI_COLON {: RESULT=new Constant(C1); RESULT.setLine(C1left); :}
			;
			
ConstDefinition ::= (ConstDefinition) IDENT:I1 ASSIGN Const:C2 {: RESULT=new ConstDefinition(I1, C2); RESULT.setLine(I1left); :};

Const ::= (NumberConstant) NUMBER:N1 {: RESULT=new NumberConstant(N1); RESULT.setLine(N1left); :}
					|
					(CharacterConstant) CHARACTER:C1 {: RESULT=new CharacterConstant(C1); RESULT.setLine(C1left); :}
					|
					(BoolConstant) BOOL:B1 {: RESULT=new BoolConstant(B1); RESULT.setLine(B1left); :}
					;

VarDecl ::= (VarDecl) Type:T1 VarList:V2 SEMI_COLON {: RESULT=new VarDecl(T1, V2); RESULT.setLine(T1left); :};

VarList ::= (Variables) VarList:V1 COMMA Var:V2 {: RESULT=new Variables(V1, V2); RESULT.setLine(V1left); :}
			|
			(Variable) Var:V1 {: RESULT=new Variable(V1); RESULT.setLine(V1left); :}
			;
			
Var ::= (PrimitiveVar) IDENT:I1 {: RESULT=new PrimitiveVar(I1); RESULT.setLine(I1left); :}
		|
		(ArrayVar) IDENT:I1 LBRACKET RBRACKET {: RESULT=new ArrayVar(I1); RESULT.setLine(I1left); :}
		;

MethodDeclSection ::= (MethodDeclarationSection) LBRACE MethodDeclList:M1 RBRACE {: RESULT=new MethodDeclarationSection(M1); RESULT.setLine(M1left); :}
					|
					(NoMethodDeclarationSection) {: RESULT=new NoMethodDeclarationSection(); :} /* epsilon */
					;
					
MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
					|
					(MethodDeclaration) MethodDecl:M1 {: RESULT=new MethodDeclaration(M1); RESULT.setLine(M1left); :}
					;
					
ClassDecl ::= (ClassDecl) CLASS IDENT:I1 ExtendsStmt:E2 LBRACE VarDeclSection:V3 MethodDeclSection:M4 RBRACE {: RESULT=new ClassDecl(I1, E2, V3, M4); RESULT.setLine(I1left); :};

ExtendsStmt ::= (ExtendsStatement) EXTENDS IDENT:I1 {: RESULT=new ExtendsStatement(I1); RESULT.setLine(I1left); :}
					| 
					(NoExtendsStatement) {: RESULT=new NoExtendsStatement(); :} /* epsilon */
					;

VarDeclSection ::= (VariableDeclarationSection) VarDeclList:V1 {: RESULT=new VariableDeclarationSection(V1); RESULT.setLine(V1left); :}
					|
					(NoVariableDeclarationSection) {: RESULT=new NoVariableDeclarationSection(); :} /* epsilon */
					;
					
VarDeclList ::= (VariablesDeclarations) VarDeclList:V1 VarDecl:V2 {: RESULT=new VariablesDeclarations(V1, V2); RESULT.setLine(V1left); :}
				|
				(VariablesDeclarationsElem) Type:T1 VarList:V2 SEMI_COLON {: RESULT=new VariablesDeclarationsElem(T1, V2); RESULT.setLine(T1left); :}
				;
				
AbstractClassDecl ::= (AbstractClassDecl) ABSTRACT CLASS IDENT:I1 ExtendsStmt:E2 LBRACE VarDeclSection:V3 AnyMethodDeclSection:A4 RBRACE {: RESULT=new AbstractClassDecl(I1, E2, V3, A4); RESULT.setLine(I1left); :};

AnyMethodDeclSection ::= (AnyMethodDeclarationSection) LBRACE AnyMethodDeclList:A1 RBRACE {: RESULT=new AnyMethodDeclarationSection(A1); RESULT.setLine(A1left); :}
						|
						(NoAnyMethodDeclarationSection) {: RESULT=new NoAnyMethodDeclarationSection(); :} /* epsilon */
						;
						
AnyMethodDeclList ::= (AnyMethodDeclarations) AnyMethodDeclList:A1 AnyMethodDecl:A2 {: RESULT=new AnyMethodDeclarations(A1, A2); RESULT.setLine(A1left); :}
						|
						(AnyMethodDeclaration) AnyMethodDecl:A1 {: RESULT=new AnyMethodDeclaration(A1); RESULT.setLine(A1left); :}
						;
						
AnyMethodDecl ::= (RealMethodDeclaration) MethodDecl:M1 {: RESULT=new RealMethodDeclaration(M1); RESULT.setLine(M1left); :}
				|
				(AbstractMethodDeclaration) ABSTRACT ReturnType:R1 IDENT:I2 LPARENTHESIS FormPars:F3 RPARENTHESIS SEMI_COLON {: RESULT=new AbstractMethodDeclaration(R1, I2, F3); RESULT.setLine(R1left); :}
				;
					
MethodDecl ::= (MethodDecl) ReturnType:R1 IDENT:I2 LPARENTHESIS FormPars:F3 RPARENTHESIS VarDeclSection:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new MethodDecl(R1, I2, F3, V4, S5); RESULT.setLine(R1left); :};

ReturnType ::= (NonVoidType) Type:T1 {: RESULT=new NonVoidType(T1); RESULT.setLine(T1left); :}
				|
				(VoidType) VOID {: RESULT=new VoidType(); :}
				;
				
FormPars ::= (FormalParameters) FormParsList:F1 {: RESULT=new FormalParameters(F1); RESULT.setLine(F1left); :}
			|
			(NoFormalParameters) {: RESULT=new NoFormalParameters(); :} /* epsilon */
			;
			
FormParsList ::= (ParameterList) FormParsList:F1 COMMA Type:T2 Var:V3 {: RESULT=new ParameterList(F1, T2, V3); RESULT.setLine(F1left); :}
				 |
				 (SinglePar) Type:T1 Var:V2 {: RESULT=new SinglePar(T1, V2); RESULT.setLine(T1left); :}
				 ;
			
StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
					|
					(SingleStatement) Statement:S1 {: RESULT=new SingleStatement(S1); RESULT.setLine(S1left); :}
					;
					
Statement ::= (MathedStmt) Matched:M1 {: RESULT=new MathedStmt(M1); RESULT.setLine(M1left); :}
				|
			  (UnmatchedStmt) Unmatched:U1 {: RESULT=new UnmatchedStmt(U1); RESULT.setLine(U1left); :}
			  |
			  (ForStmt) FOR LPARENTHESIS OptionalDesignatorStatement:O1 SEMI_COLON Condition:C2 SEMI_COLON OptionalDesignatorStatement:O3 RPARENTHESIS Statement:S4 {: RESULT=new ForStmt(O1, C2, O3, S4); RESULT.setLine(O1left); :}
			  ;
			  
Matched ::= (DesignatorStmt) DesignatorStatement:D1 SEMI_COLON {: RESULT=new DesignatorStmt(D1); RESULT.setLine(D1left); :}
			|
			(MatchedIf) IF LPARENTHESIS Condition:C1 RPARENTHESIS Matched:M2 ELSE Matched:M3 {: RESULT=new MatchedIf(C1, M2, M3); RESULT.setLine(C1left); :}
			|
			(StmtList) LBRACE StatementList:S1 RBRACE {: RESULT=new StmtList(S1); RESULT.setLine(S1left); :}
			|
			(Break) BREAK SEMI_COLON {: RESULT=new Break(); :}
			|
			(Continue) CONTINUE SEMI_COLON {: RESULT=new Continue(); :}
			|
			(Return) RETURN ReturnExpr:R1 SEMI_COLON {: RESULT=new Return(R1); RESULT.setLine(R1left); :}
			|
			(Read) READ LPARENTHESIS Designator:D1 RPARENTHESIS SEMI_COLON {: RESULT=new Read(D1); RESULT.setLine(D1left); :}
			|
			(Print) PRINT LPARENTHESIS Expr:E1 RPARENTHESIS SEMI_COLON {: RESULT=new Print(E1); RESULT.setLine(E1left); :}
			|
			(PrintWithNumber) PRINT LPARENTHESIS Expr:E1 COMMA NUMBER:N2 RPARENTHESIS SEMI_COLON {: RESULT=new PrintWithNumber(E1, N2); RESULT.setLine(E1left); :}
			;
			
ReturnExpr ::= (RetExpr) Expr:E1 {: RESULT=new RetExpr(E1); RESULT.setLine(E1left); :}
				|
				(NoReturnExpr) {: RESULT=new NoReturnExpr(); :} /* epsilon */
				;
			
Unmatched ::= (UnmatchedIf) IF LPARENTHESIS Condition:C1 RPARENTHESIS Statement:S2 {: RESULT=new UnmatchedIf(C1, S2); RESULT.setLine(C1left); :}
				|
			  (UnmatchedElse) IF LPARENTHESIS Condition:C1 RPARENTHESIS Matched:M2 ELSE Unmatched:U3 {: RESULT=new UnmatchedElse(C1, M2, U3); RESULT.setLine(C1left); :}
			  ;
			  
OptionalDesignatorStatement ::= (OptionalDesignatorStmt) DesignatorStatement:D1 {: RESULT=new OptionalDesignatorStmt(D1); RESULT.setLine(D1left); :}
								|
								(NoDesignatorStmt) {: RESULT=new NoDesignatorStmt(); :} /* epsilon */
								;
								
DesignatorStatement ::= (AssignDesignator) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new AssignDesignator(D1, A2, E3); RESULT.setLine(D1left); :}
						|
						(FunctionCall) Designator:D1 LPARENTHESIS ActPars:A2 RPARENTHESIS {: RESULT=new FunctionCall(D1, A2); RESULT.setLine(D1left); :}
						|
						(IncrementDesignator) Designator:D1 INCREMENT {: RESULT=new IncrementDesignator(D1); RESULT.setLine(D1left); :}
						|
						(DecrementDesignator) Designator:D1 DECREMENT {: RESULT=new DecrementDesignator(D1); RESULT.setLine(D1left); :}
						;
						
ActPars ::= (ActualPars) ExprList:E1 {: RESULT=new ActualPars(E1); RESULT.setLine(E1left); :}
			|
			(NoActualPars) {: RESULT=new NoActualPars(); :} /* epsilon */
			;
			
ExprList ::= (ExpressionList) ExprList:E1 COMMA Expr:E2 {: RESULT=new ExpressionList(E1, E2); RESULT.setLine(E1left); :}
			|
			 (Expression) Expr:E1 {: RESULT=new Expression(E1); RESULT.setLine(E1left); :}
			 ;
			 
Condition ::= (CondTermList) Condition:C1 OR CondTerm:C2 {: RESULT=new CondTermList(C1, C2); RESULT.setLine(C1left); :}
				|
				(SingleCondTerm) CondTerm:C1 {: RESULT=new SingleCondTerm(C1); RESULT.setLine(C1left); :}
				;
				
CondTerm ::= (CondFactList) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondFactList(C1, C2); RESULT.setLine(C1left); :}
			|
			(SingleCondFact) CondFact:C1 {: RESULT=new SingleCondFact(C1); RESULT.setLine(C1left); :}
			; 
			
CondFact ::= (ExprOp) Expr:E1 Relop:R2 Expr:E3 {: RESULT=new ExprOp(E1, R2, E3); RESULT.setLine(E1left); :}
			|
			(SingleExpr) Expr:E1 {: RESULT=new SingleExpr(E1); RESULT.setLine(E1left); :}
			;
			
Expr ::= (UnaryMinusExpression) MINUS Term:T1 AddExprPart:A2 {: RESULT=new UnaryMinusExpression(T1, A2); RESULT.setLine(T1left); :}
		|
		(NoMinusExpression) Term:T1 AddExprPart:A2 {: RESULT=new NoMinusExpression(T1, A2); RESULT.setLine(T1left); :}
		;
		
AddExprPart ::= (AddExpressionList) AddExprPart:A1 Addop:A2 Term:T3 {: RESULT=new AddExpressionList(A1, A2, T3); RESULT.setLine(A1left); :}
				|
				(NoAddExpression) {: RESULT=new NoAddExpression(); :} /* epsilon */
				;
				
Addop ::= (Minus) MINUS {: RESULT=new Minus(); :}
			|
		  (Plus) PLUS {: RESULT=new Plus(); :}
		  ;
		  
Term ::= (Term) Factor:F1 FactorList:F2 {: RESULT=new Term(F1, F2); RESULT.setLine(F1left); :};

FactorList ::= (Factors) FactorList:F1 Mulop:M2 Factor:F3 {: RESULT=new Factors(F1, M2, F3); RESULT.setLine(F1left); :}
				|
			   (NoFactorList) {: RESULT=new NoFactorList(); :} /* epsilon */
			   ;
		
Mulop ::= (Multiply) MULTIPLY {: RESULT=new Multiply(); :}
			|
		  (Divide) DIVIDE {: RESULT=new Divide(); :}
		  	|
		  (Mod) MOD {: RESULT=new Mod(); :}
		  ;
		  
Factor ::= (DesignatorFactor) Designator:D1 {: RESULT=new DesignatorFactor(D1); RESULT.setLine(D1left); :}
			|
			(DisnatorWithActParsFactor) Designator:D1 LPARENTHESIS ActPars:A2 RPARENTHESIS {: RESULT=new DisnatorWithActParsFactor(D1, A2); RESULT.setLine(D1left); :}
			|
			(ConstFactor) Const:C1 {: RESULT=new ConstFactor(C1); RESULT.setLine(C1left); :}
			|
			(NewArrayFactor) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new NewArrayFactor(T1, E2); RESULT.setLine(T1left); :}
			|
			(NewObjectFactor) NEW Type:T1 {: RESULT=new NewObjectFactor(T1); RESULT.setLine(T1left); :}
			|
			(ExpressionFactor) LPARENTHESIS Expr:E1 RPARENTHESIS {: RESULT=new ExpressionFactor(E1); RESULT.setLine(E1left); :}
			;
			
Designator ::= (Designator) IDENT:I1 DesignatorSuffix:D2 {: RESULT=new Designator(I1, D2); RESULT.setLine(I1left); :};

DesignatorSuffix ::= (ObjectDesignatorSuffix) DesignatorSuffix:D1 COLON IDENT:I2 {: RESULT=new ObjectDesignatorSuffix(D1, I2); RESULT.setLine(D1left); :}
					|
					(ArrayDesignatorSuffix) DesignatorSuffix:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new ArrayDesignatorSuffix(D1, E2); RESULT.setLine(D1left); :}
					|
					(NoDesignatorSuffix) {: RESULT=new NoDesignatorSuffix(); :} /* epsilon */
					;

Relop ::= (Equals) EQUALS {: RESULT=new Equals(); :}
		  |
		  (Differs) DIFFERS {: RESULT=new Differs(); :}
		  |
		  (Greater) GREATER {: RESULT=new Greater(); :}
		  |
		  (GreaterOrEqual) GREATER_OR_EQUAL {: RESULT=new GreaterOrEqual(); :}
		  |
		  (Less) LESS {: RESULT=new Less(); :}
		  |
		  (LessOrEqual) LESS_OR_EQUAL {: RESULT=new LessOrEqual(); :}
		  ;				
						
Assignop ::= ASSIGN {: RESULT=new AssignopDerived1(); :};
				
Type ::= (Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};